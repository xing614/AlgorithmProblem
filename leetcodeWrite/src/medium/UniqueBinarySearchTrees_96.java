package medium;
/**
 * 96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

 * @author liang
 *
 */
public class UniqueBinarySearchTrees_96 {
	
	/**
	 * 动态规划
	 * 以 1 为根的树的个数，等于左子树的个数乘以右子树的个数，左子树是 0 个元素的树，右子树是 2 个元素的树。

以 2 为根的树的个数，等于左子树的个数乘以右子树的个数，左子树是 1个元素的树，右子树也是 1 个元素的树。依此类推。
当数组为 1; 2; 3; .....; n 时，基于以下原则的构建的 BST 树具有唯一性：以 i 为根节点的树，其左子树由 [1, i-1] 构成，其右子树由 [i+1, n] 构成。
定义 f (i) 为以 [1; i] 能产生的 Unique Binary Search Tree 的数目，则
如果数组为空，毫无疑问，只有一种 BST，即空树，f (0) = 1。
如果数组仅有一个元素 1，只有一种 BST，单个节点，f (1) = 1。
如果数组有两个元素 1,2，那么有如下两种可能



f (2) = f (0) * f (1) ，1 为根的情况
        + f (1) * f (0) ， 2 为根的情况


再看一看 3 个元素的数组，可以发现 BST 的取值方式如下：
f (3) =    f (0) * f (2) ，1 为根的情况
           + f (1) * f (1) ，2 为根的情况
           + f (2) * f (0) ，3 为根的情况


所以，由此观察，可以得出 f 的递推公式为
f(i) = f(0)*f(i-1)+f(1)*f(i-2)+...
至此，问题划归为一维动态规划。
	 * @param n
	 * @return
	 */
    public int numTrees(int n) {
        int[] f = new int[n+1];
        f[0] = 1;
        f[1] = 1;
        
        for(int i=2;i<=n;i++) {
        	for(int j=1;j<=i;j++) {
        		f[i] += f[j-1]*f[i-j];
        	}
        }
        return f[n];
    }
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
