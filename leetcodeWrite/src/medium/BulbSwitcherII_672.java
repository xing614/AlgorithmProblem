package medium;
/**
 * 672. 灯泡开关 Ⅱ
 * 
 * 现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。

假设这 n 只灯泡被编号为 [1, 2, 3 ..., n]，这 4 个按钮的功能如下：

将所有灯泡的状态反转（即开变为关，关变为开）
将编号为偶数的灯泡的状态反转
将编号为奇数的灯泡的状态反转
将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, ...)
示例 1:

输入: n = 1, m = 1.
输出: 2
说明: 状态为: [开], [关]
示例 2:

输入: n = 2, m = 1.
输出: 3
说明: 状态为: [开, 关], [关, 开], [关, 关]
示例 3:

输入: n = 3, m = 1.
输出: 4
说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].
注意： n 和 m 都属于 [0, 1000].
 * @author liang
 *
 */
public class BulbSwitcherII_672 {

	/*
	 * n小于等于1的时候，属于平凡情况，可以直接返回。对于这四种类型的操作，我们可以得出如下的观察结论：

1）对于每种类型的操作，每操作两次就等于没有操作，所以其操作结果只与其操作次数的奇偶性有关。

2）前三种操作可以被规约为1次或者0次操作。例如，操作1和操作2的结果就等于操作3，而操作1，操作2和操作3的结果就是保持原貌。

3）对于n > 3的情况，其结果与n == 3的情况相同，因为当前3个灯泡的状态确定之后，后面的所有的灯泡的状态都是确定的。

所以，我们可以将所有的情况规约为m <= 3, n <= 3的情况。所以就可以直接返回结果了，时间复杂度和空间复杂度都是O(1)。
	 */
	public int flipLights(int n, int m) {
		if (m == 0 || n == 0) {
            return 1;
        }
        if (n == 1) {//只有一盏灯时，操作奇次或者偶次都是2种可能
            return 2;
        }
        if (n == 2) {//两盏灯 操作一次三种可能 关关 开关 关开，操作两次多一种可能
        	
            return m == 1 ? 3 : 4;
        }
        if (m == 1) {
            return 4;
        }
        return m == 2 ? 7 : 8;
	}
	 
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
