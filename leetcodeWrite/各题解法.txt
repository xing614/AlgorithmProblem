------------------------------------------------------------
简单
20. 有效的括号ValidParentheses:使用stack进行出栈入栈，如果为左括号一律入栈，右括号就判断栈的最后一个是否与之匹配，不匹配就false，匹配就将最后一个和这个右括号都出栈
26. 删除排序数组中的重复项RemoveDuplicatesFromSortedArray：维护current作为返回数组长度，每次出现不重复元素，就在nums[current]改变数据，并current++
21. 合并两个有序链表MergeTwoSortedLists:while判断l1和l2是否还有元素，有就对这俩第一个元素判断谁小，小的就提取数据，然后l1=l1.next，最后再把多余的元素放入
27. 移除元素:RemoveElement:与26差不多，维护一个current作为当前位置，如果num[index]！=val，则num[current++]=num[index]，如果一样就不会被覆盖到原数组中
------------------------------------------------------------
中等
16.最接近的三数之和Sum3Closest：数组先排序，固定一个数，使用left和right遍历数组，找最接近数和  O（n^2）
17.电话号码的字母组合LetterCombinationsOfAPhoneNumber:回溯法，类深度遍历，从头遍历到低后 退回一层再向下遍历，再退，直到结束
18.两数之和，三数之和，四数之和：一般方法是先排序，固定一个/两个数，令选俩变量遍历。这里可以使用深度遍历方法具体看Sum4，但是这种方法容易超出时间限制，所以还是使用两层for固定Ij，再用left和right比较好
19.删除链表的倒数第N个节点RemoveNthNodeFromEndOfList:维护两个指针，faster先走n步，之后faster和slower同时走，faster.next=null的时候slower位置是倒数n位置的prew，然后用slower删除next即可
22.括号生成GenerateParentheses:要生成适当的括号字符串，思考二叉树，，使用递归，左分支都加左括号，右分支都加右括号，设left和right代表剩下的左（右）括号数，剩余左要小于剩余右
24.两两交换链表中的节点：设置三个指针，设两个交换的为一组Group，用两个指针指向，再用一个指向这组的前一个节点，利用这三个指针交换链表
33. 搜索旋转排序数组:使用二分查找法，然后根据数组旋转特性区分low和high
24. 两两交换链表中的节点：每组两个节点，然后交换这俩，Prev，A1，A2；A1指向A2后继，Prev指向A2，Prev的后继指向A1，最后Prev=A1
34. 在排序数组中查找元素的第一个和最后一个位置FindFirstAndLastPositionOfElementInSortArrays:使用两个二分查找，分别找第一位置和最后一个位置
36. 有效的数独ValidSudoku: 判断九宫格是否可用，最普通方法就是一次判断 行 列 九宫格是否都符合要求，分别维护一个数组，比如row[1]=true表示 该行存在1这个元素，如果重复存在就false
39. 组合总和CombinationSum：回溯法
43.字符串相乘MultiplyStrings:两个字符串相乘，不能直接转成Int，因为位数太大了转成会出错，所以每次取两个数一位相乘放入自己创建的数组v[i+j]位置，最后在将这个数组使用Stringbuffer转成字符串
46. 全排列Permutations：回溯法，每次交换两个数据
47. 全排列 II Permutations2:dfs 使用一个数组维护每个位置的数是否被使用，使用则为1，再要使用的时候则直接跳过，如果当前元素与其前一个元素值相同 且 前元素未被加到list中，跳过该元素  list是当前维护的被选中的元素集合
60. 第k个排列PermutationSequence：找全排列顺序的第k的排列，找规律  k/n走过几轮，k=k%n是下一轮的k值
49. 字母异位词分组GroupAnagrams: 将由相同字母组成的不同字符串分成一组，可以使用map，key为字符串排序后相同的，value为list<String>存放每一个异位词
50. Pow(x, n):递归法，当成n/2 把x的n次方划分成两个x的n/2次方相乘，然后递归求解子问题
54. 螺旋矩阵SpiralMatrix:就是蛇形矩阵 用一个数组保存每个数是否被遍历到，遍历到就不走了然后i--或j++什么的
55. 跳跃游戏JumpGame：动态规划，保存一个全局解和一个局部解，局部解为i+nums[i]当前位置所能走的最大值，局部解为glo = Math.max(loc, glo)当前位置最大值和之前所有位置最大值的比较
56. 合并区间MergeIntervals:重叠区间合并，先排序，使用一个Comparator，然后依次判断下一个start是否在前一个区间内
59. 螺旋矩阵 IISpiralMatrix2:这个是给定n，然后生成n*n的蛇形矩阵,方法是设定四个方向一轮一轮的走，走过一轮n-2,然后回到原地后向右下走一格
-------------------------------------------------------------
困难
32. 最长有效括号LongestValidParentheses：寻找字符串最长的包含有效括号的子串的长度；使用栈stack用来保存括号对应的位置而不是（），每次是左括号就无条件Push，右括号就pop，然后判断栈是否为空，根据条件重新设置MaxLength
37. 解数独SudoKuSolver_37:使用回溯法解，辅助函数ifValid判断i j位置放入的元素是否符合九宫格要求，dfs回溯每个位置放入元素


-------------------------------------------------------------
例子：组合总和CombinationSum，22.括号生成GenerateParentheses，46全排列Permutations，17.电话号码的字母组合LetterCombinationsOfAPhoneNumber
回溯法：有时会遇到这样一类题目，它的问题可以分解，但是又不能得出明确的动态规划或是递归解法，此时可以考虑用回溯法解决此类问题。
回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。可以认为回溯算法一个"通用解题法" （DFS）
回溯法三个概念：
	约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。
	状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。
	扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。
回溯法可以被认为是一个有过剪枝的DFS过程，利用回溯法解题的具体步骤。 
        首先，要通过读题完成下面三个步骤： 
	(1) 描述解的形式，定义一个解空间，它包含问题的所有解。 
	(2) 构造状态空间树。 
	(3) 构造约束函数（用于杀死节点）。
        然后就要通过DFS思想完成回溯，完整过程如下： 
	(1) 设置初始化的方案（给变量赋初值，读入已知数据等）。 
	(2) 变换方式去试探，若全部试完则转(7)。 
	(3) 判断此法是否成功（通过约束函数），不成功则转(2)。 
	(4) 试探成功则前进一步再试探。 
	(5) 正确方案还未找到则转(2)。 
	(6) 已找到一种方案则记录并打印。 
	(7) 退回一步（回溯），若未退到头则转(2)。 
	(8) 已退到头则结束或打印无解。
回溯方法的步骤如下：
	定义一个解空间，它包含问题的解。
	用适于搜索的方式组织该空间。
	用深度优先法搜索该空间，利用限界函数避免移动到不可能产生解的子空间。
-----------------------------------------
动态规划：动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。
使用动态规划特征： 
1. 求一个问题的最优解 
2. 大问题可以分解为子问题，子问题还有重叠的更小的子问题 
3. 整体问题最优解取决于子问题的最优解（状态转移方程） 
4. 从上往下分析问题，从下往上解决问题 
5. 讨论底层的边界问题
适用范围
     最优性原理体现为问题的最优子结构特性。当一个问题的最优解中包含了子问题的最优解时，则称该问题具有最优子结构特性。
     最优性原理是动态规划的基础。任何一个问题，如果失去了这个最优性原理的支持，就不可能用动态规划设计求解。
     1.问题中的状态满足最优性原理。
     2.问题中的状态必须满足无后效性。
	所谓无后效性是指：“下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结”。
三个概念：
	最优子结构：例如F(10)=F(9)+F(8)  则F(9)和F(8)是F(10)的最优子结构 
	边界：F(1)=1，F(2)=2
	状态转移公式：F(n)=F(n-1)+F(n-2)
动态规划变形：备忘录法，用变量/数组/二维数组等记录中间过程数据，减少计算

例子：55. 跳跃游戏JumpGame，爬梯子问题，国王金矿问题，最长公共子序列
-----------------------------------------

全排列：31Next Permutation ，46 Permutations，47Permutations2 ,60Permutation Sequence